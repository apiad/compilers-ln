# El lenguaje HCL

En este capítulo definimos el lenguaje **HCL** (_Havana Compiler Language_), un lenguaje de programación didáctico diseñado para este curso.
A grandes razgos, **HCL** es un lenguaje orientado a objetos, con herencia simple, polimorfismo, y encapsulamiento a nivel de clases.
Además en **HCL** es posible definir funciones globales fuera del contexto de cualquier clase.
También es posible definir _una única expresión global_ que constituye el punto de entrada al programa.

La mayoría de las construcciones sintácticas en **HCL** son expresiones, incluyendo las instrucciones condicionales y los ciclos.
Por último, **HCL** es un lenguaje estáticamente tipado con inferencia de tipos, lo que significa que algunas (o todas) las partes de un programa pueden ser anotadas con tipos, y el compilador verificará la consistencia de todas las operaciones.

El lenguaje **HCL** ha sido diseñado para ser utilizado como mecanismo de aprendizaje y evaluación de un curso de Compilación. Por tal motivo, ciertas decisiones de diseño de lenguaje responden más a cuestiones didácticas que a cuestiones teóricas o pragmáticas. Un ejemplo ilustrativo es la inclusión de un solo tipo numérico básico. En la práctica los lenguajes de programación cuentan con varios tipos numéricos (`int`, `float`, `double`, `decimal`) para cubrir varias opciones. Sin embargo, desde el punto de vista didáctico, ya es suficiente complejidad el tener que lidiar con un tipo numérico, y la inclusión de otros no aporta nada nuevo desde nuestro punto de vista.

Otra decisión importante es el tipado estático con inferencia de tipos, que será explicado más adelante en detalle. La motivación detrás de esta característica es permitir a los estudiantes implementar primero un evaluador para el lenguaje, y luego preocuparse por la verificación de tipos. Así mismo, la decisión de tener expresiones globales, funciones globales, y clases, responde a la necesidad de introducir los diversos elementos del lenguaje poco a poco. Al tener expresiones globales, es posible implementar un intérprete de expresiones sin necesidad de resolver los problemas de contexto. Luego se pueden introducir las funciones y finalmente las características orientadas a objetos. De esta forma los estudiantes pueden ir aprendiendo sobre la marcha a medida que adicionan características al lenguaje, siempre teniendo un subconjunto válido del lenguaje implementado.

## Elementos básicos del lenguaje de HCL

El programa más sencillo en **HCL** es, por supuesto, _Hola Mundo_:

```HCL
print("Hola Mundo");
```

En **HCL** un programa puede ser simplemente una expresión (terminada en `;`), en este caso, la invocación de una función global llamada `print` (que se presentará más adelante). La cadena de texto `"Hola Mundo"` es un literal del tipo `String`, definido en la biblioteca estándar, que se comporta de la forma convencional en la mayoría de los lenguajes de programación más populares: es inmutable, y codificado en UTF8.

### Tipos básicos

Además de los literales de cadena, en **HCL** hay 2 tipos básicos adicionales: `Number`, que representa valores numéricos y `Boolean` que representa valores de verdad (con los literales usuales `True` y `False`).

El tipo `Number` representa tanto números enteros, como números con coma flotante. La semántica concreta dependerá de la arquitectura. Siempre que sea posible se representará con un valor entero de 64 (o 32) bits, o en su defecto, un valor flotante de 64 (o 32) bits, según permita la arquitectura. Las constantes numéricas se pueden escribir como `42` (valor entero) o `3.14` (valor flotante).

**HCL** tiene una jerarquía de tipos unificada, cuya raíz es el tipo `Object`. Todos los demás tipos definidos en el lenguaje son concretos.

### Expresiones elementales

En **HCL** se definen todas las expresiones usuales, en orden decreciente de precedencia:

- Operaciones lógicas entre expresiones de tipo `Boolean`: `a & b`, `a | b`, `!a`, siempre evaluadas con cortocircuito.
- Operaciones aritméticas entre expresiones de tipo `Number`: `-a`, `a % b`, `a * b`, `a / b`, `a + b`, `a - b`, con la precedencia y asociatividad usuales, y agrupamiento mediante paréntesis. El resultado es de tipo `Number` siempre.
- Comparaciones entre expresiones de tipo `Number`: `a < b`, `a > b`, `a <= b`, `a >= b`, con menor precedencia que las aritméticas, y sin asociatividad.
- Comparaciones de igualdad entre expresiones de cualquier tipo: `a == b`, `a != b`, con la semántica de igualdad por valor entre expresiones de tipo `Number`, `String` o `Boolean`, e igualdad por referencia en todos los demás tipos. Se permite comparar expresiones de cualquier tipo, y si sus tipos no son compatibles (e.j, `"Hola Mundo" == 42`) el resultado será `False`.
- El operador infijo `@` de concatenación entre `String`: `"Hello "@"World" == "Hello World"`. Para los casos donde es conveniente, el operador `@@` adiciona un espacio intermedio: `"Hello"@@"World" == "Hello World"`.

En el espacio de nombres global siempre se encontrarán además las funciones `print`, `read` y `readNumber`, además de una serie de funciones elementales matemáticas, tales como `exp`, `pow`, `log`, `sqrt`, `min` y `max`.

El valor `Null` es un valor especial que puede tener cualquier tipo, excepto `Number` y `Boolean`. Los únicos operadores válidos con un valor `Null` son `==` y `!=`.

### Variables

Las variables en **HCL** se introducen con una expresión `let`:

```HCL
let <var>[:<type>]=<init> in <body>
```

La semántica de la expresión `let` consiste en que se crea un nuevo ámbito donde se define la variable `<var>` cuyo valor es el resultado de evaluar `<init>`, y se evalua en este ámbito la expresión `<body>`.

```HCL
let msg:String="Hola Mundo" in print(msg)
```

Como se verá, indicar el tipo de una variable al declararla es opcional. Los detalles de la inferencia y verificación de tipos se darán más adelante.

Existe una variante extendida de la expresión `let` en la que se permite introducir más de una variable:

```HCL
let x=1, y=2, z=3 in x+(y*z)
```

Esta variante es semánticamente idéntica a:

```HCL
let x=1 in let y=2 in let z=3 in x+(y*z)
```

El cuerpo de una expresión `let` puede ser también una _lista de expresiones_, encerradas entre `{` y `}` y separadas por `;`, siendo el valor final de la expresión `let` el valor de la última expresión de la lista.

```HCL
let x=0 in {
    print(x==0); # Imprime True
    print(x==1); # Imprime False
}
```

Una _lista de expresiones_ **no es** una expresión en sí, es decir, no puede ser usada donde quiera que se requiera una expresión. Solamente se puede usar en el cuerpo de algunas construcciones sintácticas que se irán introduciendo poco a poco.
Es decir, el siguiente ejemplo **no es válido**:

```HCL
let x={0;1} in print(x) # NO es válido
```

Como tampoco lo es:

```HCL
{1;2} + {3;4;let x=5 in 5} # NO es válido
```

Ni ningún otro ejemplo similar donde se use un bloque de expresiones como una expresión, excepto en los contextos donde se indique explícitamente más adelante.

### Asignación

La asignación en **HCL** se realiza con el operador `:=`, y solamente es posible asignar a una variable que exista en el contexto actual:

```HCL
let color="green" in {
    print(color);    # Imprime green
    color:="blue";
    print(color);    # Imprime blue
}
```

La asignación devuelve el valor asignado, y asocia a la derecha. Tiene menor prioridad que todas las expresiones aritméticas:

```HCL
let x=0, y=0 in {
    y := x := 5 + 5;
    print(x); # 10
    print(y); # 10
    y := (x := 5) + 1;
    print(x); # 5
    print(y); # 6
}
```

### Espacios en blanco e indentación

En **HCL** los espacios en blanco no son significativos, ni tampoco la indentación. La sintaxis del lenguaje permite indicar explícitamente, cuando es necesario, el ámbito de un bloque de código. El ejemplo anterior es equivalente a:

```HCL
let x=1 in
let y=2 in
let z=3 in
    x + (y * z)
```

O cualquier otra forma de indentar que sea conveniente.

### Identificadores

Los identificadores se definen por la siguiente expresión regular (exceptuando claro las palabras reservadas):

```HCL
[a-zA-Z_][a-ZA-Z_0-9]*
```

Es decir, empiezan con un caracter del alfabeto ASCII (o `_`) y pueden opcionalmente contener números internos. Ejemplos de identificadores válidos son:

```HCL
x
name
CamelCase
smallCamelCase
snake_case
_uggly_case
hunter42
```

### Funciones

**HCL** soporta funciones globales con 2 formas sintácticas muy similares. Una función se define por un nombre, argumentos con tipo opcional, un tipo de retorno también opcional, y el cuerpo.
Todas las funciones globales deben ser definidas **antes** de la expresión global que define el _cuerpo_ del programa.

En la primera forma sintáctica, que llamamos "compacta", el cuerpo de la función debe ser exactamente una expresión (terminada en `;`):

```HCL
function isEven(n:Number):Boolean -> n % 2 == 0;
```

En la segunda forma, que llamaremos "extendida", el cuerpo de una función puede ser una _lista de expresiones_ separadas por `;`. El valor de retorno de la función es el valor de la última expresión de la lista. En esta notación **no se incluye** un `;` al final de la declaración de la función.

```HCL
function f(a, b, c) {
    a := b + c;
    b := c + a;
    c := a + b;
}

let a=1, b=2, c=3 in print(f(a,b,c)); # Imprime 13
```

En **HCL** no existe una instrucción ni palabra reservada con semántica similar a `return`. Todas las funciones tienen un tipo de retorno y devuelven siempre un valor, aunque este valor puede ser `Null`.

### Condicionales

Las expresiones condicionales se introducen con la sintaxis siguiente:

```HCL
if (<cond>) <body> [elif (<cond>) <body>]* [else <body>]?
```

Es decir, una parte `if`, seguida de cero o más partes `elif` y finalmente una parte `else` opcional.
Una expresión `if` devuelve el valor de la parte que se ejecuta. Si no se ejecuta ninguna (no hay else), devolverá `Null`. Si esto invalida la consistencia de tipos (como se verá más adelante), será necesario definir una parte `else` para garantizar al compilador/intérprete el tipo esperado.

```HCL
function fib(n) -> if (n <= 1) 1 else fib(n-1) + fib(n-2);
```

Al igual que con las expresiones `let` y las funciones, cada cuerpo puede ser o bien una expresión o una lista de expresiones.

### Ciclos

La expresión de ciclo más general en **HCL** es un ciclo `while` con la semántica común:

```HCL
while (<cond>) <body>
```

Como ya es usual, `<body>` puede ser una expresión o una lista de expresiones.

```HCL
function gcd(a, b) {
    let q = a%b in while (q != 0) {
        a := b;
        b := q;
        q := a%b;
    };

    b;
}
```

El valor de retorno de la expresión `while` es el valor de retorno del cuerpo la última vez que se ejecutó el ciclo, o `Null` en caso de que nunca se ejecute. Si es necesario, se puede adicionar una cláusula `else` para definir el valor cuando no haya ejecución.

Con esta expresión, la manera más sencilla de implementar un contador (el común ciclo `for`) es:

```HCL
let i=0 in while (i < n) {
    # ...
    i := i+1;
}
```

### Prioridad de las expresiones

Las expresiones `let`, `if` y `while` tienen **menor prioridad** que todas las expresiones elementales (aritméticas, etc.), y siempre asocian a la derecha. Por lo tanto, para poder usar una de estas expresiones dentro de una expresión aritmética, por ejemplo, se deben encerrar entre paréntesis.

Por ejemplo, el siguiente es un caso común:

```HCL
let x=5 in let y=8 in x+y
```

Que es equivalente a:

```HCL
let x=5 in (let y=8 in (x+y))
```

Sin embargo, el siguiente caso **no es válido**, pues no se puede sumar con `let` sin parentizar (`let` tiene menor prioridad):

```HCL
let x=5 in x + let y=8 in y # NO es valido
```

La forma correcta es:

```HCL
let x=5 in x + (let y=8 in y)
```

Por último, el bloque `else` siempre asocia al `if` más cercano.
Es decir, la siguiente expresión:

```HCL
if (a) if (b) y else z
```

Es no ambigua, y equivalente a:

```HCL
if (a) (if (b) y else z)
```

## Orientación a objetos en HCL

Además de las características estructuradas y funcionales presentadas, el lenguaje **HCL** soporta el concepto de _tipo_, implementado mediante _clases_. Todos los valores creados en un programa de **HCL** tienen un tipo asociado, y este tipo no puede ser cambiado en tiempo de ejecución. Por esto decimos que **HCL** es un lenguaje con tipado estático.

Aparte de los tipos nativos presentados (`Number`, `Boolean` y `String`), es posible definir nuevos tipos mediante la sintaxis:

```HCL
class <name>[<args>] [is <base>[<init>]] { [<attribute>;]* [<method>]* }
```

Todas las clases deben ser definidas **antes** que todas las funciones globales, pero esto _no impide_ que dentro del cuerpo de un método en una clase (explicado más adelante), se llame a una función global, o se use una clase definida posteriormente.

Todas las clases en **HCL** heredan de una clase base. En caso de no especificarse, esta clase será `Object`, que es la raíz de la jerarquía de tipos en **HCL**. Los tipos básicos `Number`, `String` y `Boolean` también heredan de `Object`, pero a diferencia del resto de las clases, **no es permitido heredar de los tipos básicos**. Esto se restringe ya que los tipos básicos generalmente se implementan de forma especial para garantizar una mayor eficiencia, y por lo tanto deben ser tratados con cuidado en la jerarquía de tipos.

### Atributos y métodos

Dentro del cuerpo de una clase se pueden definir dos tipos de elementos: atributos y métodos.
Los atributos se definen con un nombre, un tipo opcional, y una expresión de inicializacion _obligatoria_ (terminado en `;`):

```HCL
class Point {
    x:Number = 0;
    y:Number = 0;
}
```

Todos los atributos en **HCL** son **privados**, es decir, no está permitido acceder a ellos desde otras clases.

Los métodos se definen con una sintaxis muy similar a las funciones globales. La única diferencia es que en el contexto de un método siempre existe una variable implícita `self` que referencia a la instancia en cuestión. Es obligatorio acceder a los atributos y métodos de una clase a través de `self`, **nunca** usando su nombre directamente.

```HCL
class Point {
    x:Number = 0;
    y:Number = 0;

    translate(x,y) -> Point(self.x + x, self.y + y);
    length() -> sqrt(self.x * self.x + self.y * self.y);
}
```

Todos los atributos deben ser definidos **antes** que todos los métodos, y sus expresiones de inicialización no pueden utilizar métodos de la propia clase, ni valores de otros atributos (aunque sí pueden utilizar funciones globales). Todos los métodos en **HCL** son **públicos** y **virtuales**, redefinibles por los herederos. Además, todos los métodos son de instancia, no existen métodos estáticos, y no existe sintaxis para invocar a un método que no sea a través de una referencia a una instancia de una clase.

### Instanciando clases

Para obtener una instancia de una clase en **HCL** se utiliza el nombre de la clase como si fuera un método:

```HCL
let p = Point() in print(p.translate(5,3).length())
```

Si se desea inicializar los atributos de la clase, se pueden definir _argumentos de clase_, y su valor usarse en la inicialización de los atributos:

```HCL
class Point(x:Number, y:Number) {
    x:Number = x;
    y:Number = y;
    # ...
}
```

Una vez definidos argumentos de clase, es obligatorio proporcionar su valor al construir la clase:

```HCL
let p = new Point(5,3) in print(p.length())
```

### Redefinición y polimorfismo

En **HCL** todas las invocaciones a métodos de una instancia son polimórficas. Todos los métodos en **HCL** son virtuales, y pueden ser redefinidos, siempre que se mantenga la misma signatura (cantidad y tipo de los parámetros y retorno). La redefinición se realiza implícitamente si se define en una clase heredera un método con el mismo nombre de una clase ancestro.

```HCL
class Person(name:String) {
    name:String=name
    def greet() -> "Hello" @@ self.name
}

class Colleague is Person {
    greet() -> "Hi" @@ self.name
}
```

Al heredar de una clase se heredan por defecto las definiciones de los argumentos de clase. Por lo tanto, al instanciar una clase heredera, es obligatorio proporcionar los valores de los argumentos:

```HCL
let p = Colleague("Pete") in print(p.greet()) # "Hi Pete"
```

Sin embargo, **no está permitido** usar estos argumentos de clase implícitos en la inicialización de atributos de una clase heredera. Si es necesario usarlos, se pueden redefinir explícitamente en la clase heredera. Por otro lado, siempre que se redefinan argumentos de clase en una clase heredera, será necesario indicar explícitamente cómo se evaluan los argumentos de la clase padre en términos de los argumentos de la clase heredera:

```HCL
class Noble(title:String, who:String) is Person(title @@ who) { }

let p = Noble("Sir", "Thomas") in print(p.greet()) # Hello Sir Thomas
```

En caso de no redefinirlo, el comportamiento es como si implícitamente se hubiera definido un constructor con la implementación "heredada" del ancestro más cercano que tiene un constructor definido, y se le pasan los mismos argumentos.

```HCL
let c = new Colleague("Pete") in c.greet() # Hi Pete
```

### Evaluando el tipo dinámico

La expresión `case` permite comparar el tipo dinámico de una expresión con una lista de tipos posibles. Su sintaxis es la siguiente:

```HCL
case <expr> of {
    [<id>:<type> -> <body> ;]+
}
```

Esta expresión compara el tipo dinámico de `<expr>` contra cada uno de los tipos `<type>`, y ejecuta el `<body>` correspondiente a la rama del ancestro más cercano:

```HCL
class A { }
class B inherits A { }
class C inherits B { }
class D inherits A { }

case new C() of {
    a:A -> print("A");
    b:B -> print("B"); # Se ejecuta esta rama
    d:D -> print("C");
}
```

En caso de ninguna rama ser válida en tiempo de ejecución, se lanza un error. En caso de poderse inferir el tipo de `<expr>`, se intentará validar la compatibilidad con los tipos `<type>`, y se lanzará un error semántico de existir. El cuerpo de una rama cualquiera puede ser una lista de expresiones entre `{` y `}` si fuera necesario, como sucede con las funciones.

Existe una versión compacta también de `case` cuando hay una sola rama, con la forma:

```HCL
case <expr> of <id>:<type> -> <body>
```

Esta forma puede usarse para evaluar un "downcast" en **HCL**, cuando se conoce con certeza el tipo dinámico de un objeto.

Por ejemplo, el siguiente programa lanza error semántico pues `o` es de tipo estático `Object`, explícitamente declarado, por lo que no se puede sumar.

```
function dunno():Object -> 40;

let o:Object = something() in o + 2; # error semántico
```

Sin embargo, usando `case` se puede forzar al verificador de tipos a que infiera `Number` para esta expresión, lanzando error en tiempo de ejecución si realmente el tipo dinámico fuera otro.

```
function dunno():Object -> 40;

let o:Object = something() in case o of y:Number -> y + 2;
```

## Verificación e inferencia de tipos en HCL

Un programa en **HCL** no necesita especificar todas las anotaciones de tipos, si son inferibles dado el contexto. Formalizar precisamente en qué casos es posible inferir o no el tipo de una declaración es un problema complicado, y no lo intentaremos en este punto. Por el contrario, presentaremos algunos ejemplos donde es posible inferir el tipo, y otros ejemplos donde el mecanismo de inferencia de tipos de **HCL** no será capaz de deducirlo.

El caso más sencillo, es cuando en una declaración de variable se omite el tipo. En este caso, el tipo se infiere de la expresión de inicialización:

```HCL
let x=3+2 in case x of y:Number -> print("Ok);
```

De igual forma sucede con los atributos de una clase, cuando pueden ser inferidos por el tipo de la expresión de inicialización:

```HCL
class Point(x:Number, y:Number) {
    x=x;
    y=y;
    # ...
}
```

Un caso más complejo es cuando se deja sin especificar el tipo de retorno de una función, pero puede ser inferido por a partir de su cuerpo:

```HCL
function succ(n:Number) -> n + 1;
```

En el caso anterior, es fácil inferir el tipo de retorno de `succ` porque la expresión retorna exactamente el mismo tipo que un argumento. En estos casos, es posible incluso no especificar el tipo del argumento, ya que el operador `+` solo está definido para `Number`:

```HCL
function succ(n) -> n + 1;
```

Sin embargo, a veces no es posible inferir el tipo de un argumento a partir de su uso _dentro del cuerpo_ de una función. En el caso siguiente, aunque sabemos que el tipo del argumento `p` debe ser `Point` para aceptar la invocación, _no se garantiza_ que el mecanismo de inferencia de tipos deba deducirlo. Dependiendo de la implementación, en estos casos se permite lanzar error semántico indicando que no fue posible inferir el tipo del argumento `p`.

```HCL
function step(p) -> p.translate(1,1);

let p=Point(0,0) in step(p); # Puede lanzar error semántico
```

Por último, especial complejidad acarrean las funciones recursivas:

```HCL
function fact(n) -> if (n<0) 1 else n*fact(n-1);
```

El ejemplo anterior permite inferir simultáneamente el tipo del argumento `n` y del retorno, ya que se usa el retorno de la función recursiva en una operación `+` que solo está definida para `Number`. Sin embargo, en el ejemplo siguiente:

```HCL
function ackermann(m, n) ->
    if   (m==0) n+1
    elif (n==0) ackermann(m-1, 1)
    else        ackermann(m-1, ackermann(m, n-1));
```

Como el tipo de retorno no se utiliza explícitamente en una operación matemática, no es trivial deducir que su tipo de retorno es `Number`, ya que `Object` funcionaría también como tipo de retorno. En estos casos, se desea que el mecanismo de inferencia deduzca _el tipo más concreto_ para el retorno y _el tipo más abstracto_ para los argumentos que sea posible.

Finalmente, dos funciones mutuamente recursivas:

```HCL
def f(a, b) -> is (a==1) b else g(a+1, b/2);
def g(a, b) -> if (b==1) a else f(a/2, b+1)
```

En este caso, es posible teóricamente inferir que `f` y `g` ambos retornar tipo `Number`, pero dada la complejidad de manejar la inferencia de tipos en más de una función a la vez, no se garantiza que sea posible deducir los tipos en este caso.

## Formalización del lenguaje HCL

En esta sección presentaremos una descripción formal de **HCL**, en términos sintácticos, semánticos y operacionales. Esta sección debe servir como referencia para la construcción de un compilador de **HCL**, pero recomendamos las secciones anteriores que explican de forma más intuitiva todos los elementos relevantes del lenguaje.

## Sintaxis de HCL

Una gramática posible para **HCL** se muestra a continuación. Nótese que por motivos didácticos, esta gramática es ambigua. En particular, la asociatividad y prioridad de los distintos tipos de expresiones se deja sin resolver, para dar espacio a los estudiantes a que resuelvan estos problemas.

### Terminales

Los terminales de **HCL** son:

```Grammar
NUMBER  := [0-9]+(.[0-9]+)?
STRING  := '"' UNICODE* '"' # Todos los caracteres unicode válidos
BOOLEAN := 'True' | 'False'
LITERAL := NUMBER | STRING | BOOLEAN
ID      := [a-zA-Z_][a-zA-Z0-9]*
```

Un programa en **HCL** tiene tres partes.

```Grammar
<program> := [<class>]* [<function>]* [<expr>]?
```

Una clase contiene atributos y métodos.

```Grammar
<class> := 'class' ID ['is' ID] { [<attr>]* [<method>]* }
```
